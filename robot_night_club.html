<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Vector // AGI Core</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Rajdhani', sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* --- HUD V9.6 --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 1000; transition: opacity 0.8s ease;
            backdrop-filter: blur(20px);
        }
        
        h1 { 
            font-weight: 700; font-size: 3.5rem; letter-spacing: 12px; text-transform: uppercase; 
            margin-bottom: 20px; text-align: center; 
            background: -webkit-linear-gradient(#fff, #00ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 20px;
        }

        .subtitle {
            font-size: 1.2rem; color: #888; letter-spacing: 4px; margin-bottom: 40px; text-transform: uppercase;
        }
        
        button#start-btn {
            padding: 20px 80px; 
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.5);
            color: #fff; font-family: 'Rajdhani', sans-serif; font-size: 18px; letter-spacing: 6px; font-weight: 600;
            cursor: pointer; transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1); text-transform: uppercase;
            position: relative; overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        button#start-btn:hover { 
            background: rgba(0, 255, 255, 0.3); 
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6);
            letter-spacing: 8px;
        }
        
        #ui-layer {
            position: absolute; top: 40px; left: 40px; 
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px; pointer-events: none; font-weight: 600; letter-spacing: 2px;
            display: flex; flex-direction: column; gap: 8px;
            z-index: 100;
        }
        .hud-line { display: flex; align-items: center; gap: 10px; }
        .hud-dot { width: 6px; height: 6px; background: #00ffaa; border-radius: 50%; box-shadow: 0 0 10px #00ffaa; }

        #score-board {
            position: absolute; top: 40px; right: 40px;
            text-align: right; pointer-events: none;
            z-index: 100;
        }
        #score-val {
            font-size: 5rem; font-weight: 700; color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            line-height: 0.9;
        }
        #score-label { font-size: 0.9rem; color: #aaa; letter-spacing: 6px; }

        #mcp-subtitles {
            position: absolute; top: 15%; width: 100%; text-align: center;
            font-size: 1.5rem; color: #00ffff; letter-spacing: 2px; text-transform: uppercase;
            text-shadow: 0 0 20px #00ffff; pointer-events: none; opacity: 0; transition: opacity 0.5s;
            font-weight: 600; font-family: "Courier New", monospace;
            padding: 0 20px;
            z-index: 90;
        }

        #controls-box {
            position: absolute; bottom: 40px; right: 40px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
            pointer-events: auto;
            z-index: 100;
        }
        
        .hud-btn {
            background: rgba(5, 10, 20, 0.6); 
            border: 1px solid rgba(0, 255, 255, 0.3); 
            color: rgba(255, 255, 255, 0.8);
            padding: 10px 15px; cursor: pointer; text-transform: uppercase;
            font-family: 'Rajdhani'; font-size: 14px; letter-spacing: 2px;
            transition: all 0.2s; backdrop-filter: blur(5px);
            width: 140px; text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .hud-btn:hover { 
            background: rgba(0, 255, 255, 0.2); 
            border-color: #00ffff; color: #fff;
        }
        .hud-hint {
            font-size: 10px; color: #666; letter-spacing: 1px; margin-top: 5px; text-transform: uppercase;
        }

        #joystick-zone {
            position: absolute; bottom: 40px; left: 40px;
            width: 180px; height: 180px;
            background: rgba(0, 255, 255, 0.08);
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 50%;
            display: none; touch-action: none;
            backdrop-filter: blur(5px);
            opacity: 1;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 70px; height: 70px;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), inset 0 0 15px rgba(0, 255, 255, 0.2);
            transition: all 0.1s ease;
        }

        #mobile-zoom-controls {
            position: absolute; bottom: 40px; right: 40px;
            display: none; flex-direction: column; gap: 10px;
            z-index: 100;
        }
        .zoom-btn {
            width: 60px; height: 60px;
            background: rgba(0, 255, 255, 0.15);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            color: #00ffff;
            font-size: 28px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .zoom-btn:active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            #joystick-zone { display: block; }
            #mobile-zoom-controls { display: flex; }
            #score-board { top: 20px; right: 20px; transform: scale(0.7); transform-origin: top right; }
            h1 { font-size: 2rem; letter-spacing: 5px; }
            #controls-box { bottom: 250px; right: 20px; transform: scale(0.85); transform-origin: bottom right; }
            .hud-btn { width: 120px; font-size: 12px; padding: 8px 12px; }
            #mcp-subtitles { font-size: 1.2rem; top: 20%; }
            #ui-layer { left: 20px; top: 20px; font-size: 10px; }
        }
    </style>
</head>
<body>

<div id="overlay">
    <h1>AGI // CORE</h1>
    <div class="subtitle">Cognitive Versatility Benchmark</div>
    <button id="start-btn">Initialize</button>
</div>

<div id="ui-layer">
    <div class="hud-line"><div class="hud-dot"></div>VECTOR ENGINE V9.6</div>
    <div class="hud-line"><div class="hud-dot" style="background:#00aaff; box-shadow:0 0 10px #00aaff;"></div>FLUID REASONING: ACTIVE</div>
    <div class="hud-line"><div class="hud-dot" style="background:#ff0044; box-shadow:0 0 10px #ff0044;"></div>MCP: WATCHING</div>
</div>

<div id="score-board">
    <div id="score-val">0</div>
    <div id="score-label">DATA</div>
</div>

<div id="mcp-subtitles"></div>

<div id="controls-box">
    <button class="hud-btn" id="switch-char-btn">Switch Unit</button>
    <button class="hud-btn" id="reset-pos-btn">Reset Pos</button>
    <div class="hud-hint">Drag: Rotate/Tilt Camera</div>
</div>

<div id="joystick-zone">
    <div id="joystick-knob"></div>
</div>

<div id="mobile-zoom-controls">
    <button class="zoom-btn" id="zoom-in-btn">+</button>
    <button class="zoom-btn" id="zoom-out-btn">âˆ’</button>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- Configuration ---
    const CONFIG = {
        voxelSize: 0.15,
        accel: 110.0,       
        friction: 5.0,     
        bloomStrength: 1.5,
        bloomRadius: 0.6,
        bloomThreshold: 0.15
    };

    let camera, scene, renderer, composer;
    let clock = new THREE.Clock();
    let playerRobot; 
    let cursors = [];
    let lightCycles = [];
    let tanks = [];
    let mcpEntity; 
    
    // Inputs & Camera
    const input = { x: 0, y: 0 };
    let isDragging = false;
    let previousMouseX = 0;
    let previousMouseY = 0;
    let cameraAngle = 0;
    let cameraHeightFactor = 1.0; 
    
    // Game State
    let cameraZoom = 40;
    let targetCameraZoom = 40;
    let score = 0;
    
    // --- MCP DATA STREAMS ---
    const MCP_PHRASES = [
        "End of line.", "I will assimilate you.", "Resolution imminent.", "De-rez.", 
        "Null pointer detected.", "System breach.", "Grid locked.",
        "Measuring Mental Comparison Speed (R7)...",
        "Pointer Fluency: Calibrating...",
        "Parity check: 14, 9. Result: Mismatch.",
        "Alpha-sort: Apple, Apricot. Processing...",
        "Center for AI Safety: Monitoring.",
        "Model Context Protocol: Standardizing boundaries.",
        "Deep Learning: Hierarchical feature extraction active.",
        "Chain of Thought: Intermediate reasoning steps engaged.",
        "Autonomous Agents: Self-directed goal seeking.",
        "Transformer Attention: Quadratic complexity.",
        "Uncaught TypeError: undefined is not a function.",
        "SEGFAULT: Memory access violation.",
        "Garbage Collection: Sweeping..."
    ];

    // --- Dynamic Audio System (Acid Techno) ---
    let audioCtx;
    let isPlaying = false;
    let masterGain;
    let delayNode;
    let noteIndex = 0;
    let measure = 0;
    
    const BASS_SCALE = [65.41, 77.78, 98.00, 116.54, 130.81]; // C2 scale
    const LEAD_SCALE = [261.63, 311.13, 392.00, 466.16, 523.25, 622.25];

    const audioSystem = {
        nextNoteTime: 0,
        tempo: 100,
        scheduleAheadTime: 0.1,
        voicesLoaded: false,
        selectedVoice: null,

        init: function() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;

            delayNode = audioCtx.createDelay();
            delayNode.delayTime.value = 0.375;
            const delayFeedback = audioCtx.createGain();
            delayFeedback.gain.value = 0.4;

            const delayFilter = audioCtx.createBiquadFilter();
            delayFilter.frequency.value = 1000;

            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayFilter);
            delayFilter.connect(delayNode);
            delayNode.connect(masterGain);
            masterGain.connect(audioCtx.destination);

            this.nextNoteTime = audioCtx.currentTime;
            this.scheduler();

            // Initialize speech synthesis voices
            this.loadVoices();
        },

        loadVoices: function() {
            const setVoice = () => {
                const voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    // Filter for English voices (less restrictive for mobile)
                    let englishVoices = voices.filter(v =>
                        v.lang.startsWith('en-') &&
                        !v.lang.includes('da-') // Exclude Danish
                    );

                    // If no English voices found, just use any available voice
                    if (englishVoices.length === 0) {
                        englishVoices = voices;
                    }

                    // Prioritize voices in order of preference
                    this.selectedVoice =
                        // First: Try high-quality cloud voices
                        englishVoices.find(v =>
                            v.name.includes('Google US English') ||
                            v.name.includes('Google UK English') ||
                            v.name.includes('Microsoft David') ||
                            v.name.includes('Microsoft Zira') ||
                            v.name.includes('Samantha') || // iOS default
                            v.name.includes('Daniel') // iOS UK
                        ) ||
                        // Second: Try any US or UK English voice
                        englishVoices.find(v => v.lang === 'en-US' || v.lang === 'en-GB') ||
                        // Third: Try any English voice
                        englishVoices.find(v => v.lang.startsWith('en-')) ||
                        // Last resort: Use first available voice
                        englishVoices[0] || voices[0];

                    this.voicesLoaded = true;
                    console.log('Voice selected:', this.selectedVoice?.name, this.selectedVoice?.lang);
                }
            };

            // Try to load voices immediately
            setVoice();

            // Also listen for voices changed event (Chrome/Safari requires this)
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = setVoice;
            }

            // For mobile: Try again after a delay
            setTimeout(setVoice, 100);
            setTimeout(setVoice, 500);
        },

        speak: function(text, pitch = 1.0, isMCP = false) {
            if (!window.speechSynthesis) return;

            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            const u = new SpeechSynthesisUtterance(text);

            // Mobile fix: Always get fresh voice list
            const voices = window.speechSynthesis.getVoices();

            // Try to use pre-selected voice
            let voiceToUse = this.selectedVoice;

            // If no voice selected or voices not loaded, try to find one now
            if (!voiceToUse || voices.length === 0) {
                // Get voices again (mobile browsers sometimes need this)
                const freshVoices = window.speechSynthesis.getVoices();

                if (freshVoices.length > 0) {
                    // Find the best English voice
                    voiceToUse = freshVoices.find(v =>
                        v.lang === 'en-US' || v.lang === 'en-GB'
                    ) || freshVoices.find(v =>
                        v.lang.startsWith('en-') && !v.lang.includes('da-')
                    ) || freshVoices[0];
                }
            }

            // Set voice and language
            if (voiceToUse) {
                u.voice = voiceToUse;
                u.lang = voiceToUse.lang;
            } else {
                // Fallback: just set language (browser will pick default)
                u.lang = 'en-US';
            }

            if (isMCP) {
                // MCP voice: Deep, authoritative, but still natural and clear
                u.rate = 0.85;
                u.pitch = 0.75;
                u.volume = 1.0;
                const sub = document.getElementById('mcp-subtitles');
                if (sub) {
                    sub.innerText = text;
                    sub.style.opacity = 1;
                    sub.style.textShadow = `2px 0 0 #ff0044, -2px 0 0 #00ffff`;
                    setTimeout(() => { sub.style.opacity = 0; }, 3500);
                }
            } else {
                // Regular voice: Natural, clear, and human-like
                u.rate = 1.0;
                u.pitch = pitch;
                u.volume = 0.7;
            }

            // Error handling for mobile
            u.onerror = (event) => {
                console.warn('Speech synthesis error:', event.error);
            };

            try {
                window.speechSynthesis.speak(u);
            } catch (e) {
                console.warn('Speech synthesis failed:', e);
            }
        },

        playAcidBass: function(freq, dur, vol, accent = false) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, t);
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = accent ? 18 : 8; 
            const startFreq = accent ? 3000 : 800;
            const endFreq = 100;
            filter.frequency.setValueAtTime(startFreq, t);
            filter.frequency.exponentialRampToValueAtTime(endFreq, t + dur * 0.8);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.01, t);
            gain.gain.linearRampToValueAtTime(vol * 0.8, t + 0.02); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            gain.connect(delayNode); 
            osc.start(t);
            osc.stop(t + dur);
        },

        playTone: function(freq, type, dur, vol) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(freq, t);
            osc.type = type;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(vol, t + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(t);
            osc.stop(t + dur);
        },

        playNoise: function(type, dur, vol) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * dur;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            const gain = audioCtx.createGain();
            if (type === 'hat') {
                filter.type = 'highpass'; filter.frequency.value = 8000;
                gain.gain.setValueAtTime(vol * 0.7, t); 
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
            } else if (type === 'clap') {
                filter.type = 'bandpass'; filter.frequency.value = 1200; filter.Q.value = 1;
                gain.gain.setValueAtTime(vol * 0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15); 
            }
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            if(type === 'clap') gain.connect(delayNode);
            noise.start(t);
        },

        scheduler: function() {
            while (this.nextNoteTime < audioCtx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.nextNoteTime);
                this.nextNote();
            }
            if(isPlaying) requestAnimationFrame(this.scheduler.bind(this));
        },

        nextNote: function() {
            const secondsPerBeat = 60.0 / this.tempo;
            this.nextNoteTime += 0.25 * secondsPerBeat;
            noteIndex++;
            if(noteIndex % 16 === 0) measure++;
        },

        scheduleNote: function(time) {
            const step = noteIndex % 16;
            const isBuild = measure >= 4;
            const isFull = measure >= 8;
            if (step % 2 === 0) {
                const note = BASS_SCALE[(noteIndex / 2) % BASS_SCALE.length];
                const accent = Math.random() > 0.7;
                this.playAcidBass(note, 0.25, 0.4, accent);
            }
            if (step % 4 === 0 && (isBuild || isFull)) this.playTone(50, 'sine', 0.2, 0.7);
            if (isBuild || isFull) {
                if (step % 4 === 2) this.playNoise('hat', 0.1, 0.15);
                else this.playNoise('hat', 0.05, 0.05);
            }
            if (step % 8 === 4 && isFull) this.playNoise('clap', 0.2, 0.3);
            if (step % 3 === 0 && Math.random() > 0.7) {
                const note = LEAD_SCALE[Math.floor(Math.random() * LEAD_SCALE.length)];
                this.playTone(note, 'triangle', 0.4, 0.1); 
            }
        }
    };

    // --- 3D Scene ---
    function init() {
        const container = document.body;
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" }); 
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.Fog(0x050510, 60, 400);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const ambient = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(0, 50, 20);
        scene.add(dirLight);

        createVectorEnvironment();
        createMasterControlProgram(); 
        
        playerRobot = new VoxelRobot(0xff5500, 'INVADER'); 
        scene.add(playerRobot.mesh);

        createCursors(); // RESTORED VECTOR CURSORS
        createLightCycles();
        createTanks(); 

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
        
        window.addEventListener('wheel', onMouseWheel, { passive: false });

        setupJoystick();
        setupMobileZoom();
        window.addEventListener('resize', onWindowResize);
        animate();
    }

    // --- MASTER CONTROL PROGRAM (MCP) ---
    function createMasterControlProgram() {
        mcpEntity = new THREE.Group();
        const wireMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.8 });
        
        const head = new THREE.Mesh(new THREE.CylinderGeometry(20, 20, 40, 16, 4, true), wireMat);
        head.rotation.x = Math.PI / 2; mcpEntity.add(head);

        const hat = new THREE.Mesh(new THREE.ConeGeometry(20, 15, 16, 2, true), wireMat);
        hat.rotation.x = -Math.PI / 2; hat.position.z = -25; mcpEntity.add(hat);

        const eyeGeo = new THREE.ConeGeometry(5, 12, 4);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0044, wireframe: true });
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(-8, 6, 18); leftEye.rotation.x = Math.PI/2; mcpEntity.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(8, 6, 18); rightEye.rotation.x = Math.PI/2; mcpEntity.add(rightEye);

        const mouth = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 8, 1, true), wireMat);
        mouth.rotation.z = Math.PI/2; mouth.position.set(0, -10, 21); mcpEntity.add(mouth);

        mcpEntity.position.set(0, 60, -80);
        mcpEntity.userData = { speakTimer: 4.0, baseY: 60 };
        scene.add(mcpEntity);
    }

    function updateMCP(delta) {
        if (!mcpEntity || !playerRobot) return;
        mcpEntity.lookAt(playerRobot.mesh.position);
        mcpEntity.position.y = mcpEntity.userData.baseY + Math.sin(clock.elapsedTime * 0.5) * 2.0;
        mcpEntity.userData.speakTimer -= delta;
        if (mcpEntity.userData.speakTimer <= 0) {
            const phrase = MCP_PHRASES[Math.floor(Math.random() * MCP_PHRASES.length)];
            audioSystem.speak(phrase, 0.1, true); 
            mcpEntity.userData.speakTimer = 8.0 + Math.random() * 12.0; 
        }
    }

    // --- PIXEL ROBOT (20 Character Types) ---
    class VoxelRobot {
        constructor(colorHex, type) {
            this.velocity = new THREE.Vector3(); 
            this.expressionTimer = 0;
            this.scale = CONFIG.voxelSize;
            this.baseColor = new THREE.Color(colorHex);
            this.type = type;

            this.patterns = {
                'INVADER': { normal: ["00100000100", "00010001000", "00111111100", "01101110110", "11111111111", "10111111101", "10100000101", "00011011000"], hurt: ["00000000000", "01010001010", "00100000100", "00000000000", "00111111100", "01000000010", "10000000001", "00000000000"] },
                'GHOST':   { normal: ["00011111000", "00111111100", "01100100110", "01100100110", "01111111110", "01111111110", "01101110110", "01001010010"], hurt: ["00000000000", "00100000100", "01010001010", "00000000000", "01111111110", "01010101010", "01000000010", "00000000000"] },
                'SHIP':    { normal: ["00000100000", "00001110000", "00001110000", "00011011000", "00111011100", "01111011110", "11111111111", "10000000001"], hurt: ["00000100000", "01001010010", "00101010100", "00010001000", "00100000100", "01000000010", "10000000001", "00000000000"] },
                'TANK':    { normal: ["00000100000", "00000100000", "01101110110", "11111111111", "11111111111", "10011111001", "10011111001", "01100000110"], hurt: ["00000000000", "00000100000", "01010101010", "10000000001", "01000000010", "00100000100", "00010101000", "00000000000"] },
                'GLIDER':  { normal: ["00000000000", "00001000000", "00000100000", "00011100000", "00000000000", "00000000000", "00000000000", "00000000000"], hurt: ["00000000000", "00010100000", "00001000000", "00011100000", "00000000000", "00000000000", "00000000000", "00000000000"] },
                'PLUMBER': { normal: ["00011111100", "00111111111", "00100111000", "00101111100", "00101111100", "00011111110", "00011000110", "00111000111"], hurt: ["00000000000", "00101000100", "00010001000", "00001110000", "00000000000", "00010001000", "00001010000", "00000000000"] },
                'FACE':    { normal: ["11111111111", "11111111111", "11001110011", "11001110011", "11111111111", "11110001111", "11110001111", "11110101111"], hurt: ["11111111111", "11010101011", "11101110111", "11010101011", "11111111111", "11110001111", "11100000111", "11110101111"] },
                'SWORD':   { normal: ["00000100000", "00000100000", "00000100000", "00000100000", "00000100000", "00111111100", "00000100000", "00000100000"], hurt: ["00000000000", "00100000100", "00010001000", "00001010000", "00000100000", "00111011100", "00000100000", "00000100000"] },
                'BLOCK':   { normal: ["00001100000", "00001100000", "00001100000", "00001100000", "00001111000", "00001111000", "00000000000", "00000000000"], hurt: ["00000000000", "00010010000", "00001100000", "00001100000", "00011011000", "00011011000", "00000000000", "00000000000"] },
                'PONG':    { normal: ["00000000000", "00000000000", "00001110000", "00001110000", "00001110000", "00000000000", "00000000000", "00000000000"], hurt: ["00000000000", "00000000000", "00001010000", "00000100000", "00001010000", "00000000000", "00000000000", "00000000000"] },
                'DISK':    { normal: ["00011111000", "00110001100", "01100000110", "01000100010", "01000100010", "01100000110", "00110001100", "00011111000"], hurt: ["00000000000", "00101010100", "01000000010", "00000000000", "00000000000", "01000000010", "00101010100", "00000000000"] },
                'BUG':     { normal: ["00100000100", "10101010101", "01111111110", "00111111100", "01111111110", "01111111110", "00100000100", "10100000101"], hurt: ["00000000000", "00001010000", "01010001010", "00001010000", "01010001010", "01000000010", "00000000000", "00000000000"] },
                'HEART':   { normal: ["00000000000", "00110001100", "01111011110", "01111111110", "01111111110", "00111111100", "00011111000", "00000100000"], hurt: ["00000000000", "00100000100", "01010001010", "01000000010", "01000000010", "00100000100", "00010001000", "00000000000"] },
                'KEY':     { normal: ["00001100000", "00011110000", "00011110000", "00001100000", "00001100000", "00011100000", "00011100000", "00011100000"], hurt: ["00000000000", "00010010000", "00001100000", "00001100000", "00001100000", "00010100000", "00010100000", "00000000000"] },
                'EYE':     { normal: ["00001110000", "00111111100", "01111111110", "01110101110", "01111111110", "00111111100", "00001110000", "00000000000"], hurt: ["00000000000", "00101010100", "01000000010", "01001010010", "01000000010", "00101010100", "00000000000", "00000000000"] },
                // New 5 Characters
                'MECH':    { normal: ["11000000011", "11001110011", "11111111111", "01111011110", "00111111100", "00011111000", "00100000100", "11000000011"], hurt: ["11000000011", "10001010001", "11001010011", "01001010010", "00101110100", "00010101000", "00000000000", "11000000011"] },
                'ALIEN':   { normal: ["00100000100", "00010001000", "11111111111", "10111111101", "11101010111", "00010101000", "00100000100", "10000000001"], hurt: ["00000000000", "00000000000", "10111111101", "01010101010", "01000000010", "00000000000", "00000000000", "10000000001"] },
                'SAMURAI': { normal: ["00001110000", "01111111110", "11011111011", "00001110000", "00011111000", "00111111100", "00100000100", "11000000011"], hurt: ["00000100000", "00111011100", "00001010000", "00001010000", "00010001000", "00100000100", "00000000000", "00000000000"] },
                'CYBORG':  { normal: ["00111111100", "01100000110", "01011111010", "01010001010", "01011111010", "01100000110", "00111111100", "00000000000"], hurt: ["00000000000", "01000000010", "00010101000", "00000000000", "00010101000", "01000000010", "00000000000", "00000000000"] },
                'DRAGON':  { normal: ["00000110000", "00001111000", "01111111110", "11110101111", "11111111111", "00111011100", "00010001000", "11100000111"], hurt: ["00000000000", "00001010000", "01011111010", "10100000101", "10100000101", "00010001000", "00000000000", "10000000001"] }
            };

            const mat = new THREE.MeshStandardMaterial({ 
                color: colorHex, roughness: 0.2, metalness: 0.5, emissive: colorHex, emissiveIntensity: 0.6 
            });
            const geom = new THREE.BoxGeometry(this.scale, this.scale, this.scale);

            this.mesh = new THREE.InstancedMesh(geom, mat, 120); 
            this.mesh.castShadow = true;
            this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            
            this.updateVoxels(this.patterns[this.type].normal);
            this.mesh.position.y = 2.0;
        }

        switchType(newType) {
            if (this.patterns[newType]) {
                this.type = newType;
                this.setExpression('NORMAL');
                const colors = {
                    'INVADER': 0xff5500, 'GHOST': 0xff00aa, 'SHIP': 0x00aaff,
                    'TANK': 0xff0000, 'GLIDER': 0x00ff00, 'PLUMBER': 0x0000ff,
                    'FACE': 0x00aa00, 'SWORD': 0xcccccc, 'BLOCK': 0xffff00, 'PONG': 0xffffff,
                    'DISK': 0x00ccff, 'BUG': 0xccff00, 'HEART': 0xff0066, 'KEY': 0xffaa00, 'EYE': 0x9900ff,
                    'MECH': 0x333333, 'ALIEN': 0x00ff33, 'SAMURAI': 0xff3300, 'CYBORG': 0x999999, 'DRAGON': 0xffcc00
                };
                this.baseColor.setHex(colors[newType] || 0xffffff);
                this.mesh.material.color.copy(this.baseColor);
                this.mesh.material.emissive.copy(this.baseColor);
            }
        }

        updateVoxels(gridPattern) {
            const startX = -(gridPattern[0].length * this.scale) / 2;
            const startY = (gridPattern.length * this.scale);
            let index = 0;
            const dummy = new THREE.Object3D();

            for(let r=0; r<gridPattern.length; r++) {
                const rowStr = gridPattern[r];
                for(let c=0; c<rowStr.length; c++) {
                    if(rowStr[c] === '1') {
                        dummy.position.set(startX + c * this.scale, startY - r * this.scale, 0);
                        dummy.updateMatrix();
                        this.mesh.setMatrixAt(index++, dummy.matrix);
                    }
                }
            }
            for(let i=index; i<120; i++) {
                dummy.position.set(0, -1000, 0); 
                dummy.updateMatrix();
                this.mesh.setMatrixAt(i, dummy.matrix);
            }
            this.mesh.instanceMatrix.needsUpdate = true;
        }

        setExpression(type) {
            if (type === 'HURT') {
                this.updateVoxels(this.patterns[this.type].hurt);
                this.mesh.material.color.setHex(0xffffff); 
                this.mesh.material.emissive.setHex(0xffffff);
                this.expressionTimer = 0.5;
            } else {
                this.updateVoxels(this.patterns[this.type].normal);
                this.mesh.material.color.copy(this.baseColor);
                this.mesh.material.emissive.copy(this.baseColor);
            }
        }

        update(delta, input, cameraRotY) {
            if (this.expressionTimer > 0) {
                this.expressionTimer -= delta;
                if (this.expressionTimer <= 0) this.setExpression('NORMAL');
            }
            const angle = cameraRotY; 
            const forceX = Math.sin(angle) * input.y + Math.cos(angle) * input.x;
            const forceZ = Math.cos(angle) * input.y - Math.sin(angle) * input.x;
            this.velocity.x += forceX * CONFIG.accel * delta;
            this.velocity.z -= forceZ * CONFIG.accel * delta;
            this.velocity.multiplyScalar(1 - (CONFIG.friction * delta));
            this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));
            const speed = this.velocity.length();
            this.mesh.position.y = 2.0 + Math.sin(clock.elapsedTime * 12) * (0.1 + speed * 0.05);
            const relativeVelX = this.velocity.x * Math.cos(angle) - this.velocity.z * Math.sin(angle);
            this.mesh.rotation.z = -relativeVelX * 0.05; 
            this.mesh.rotation.x = speed * 0.02; 
            if (speed > 1.0) {
                const targetRot = Math.atan2(this.velocity.x, this.velocity.z);
                const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), targetRot);
                this.mesh.quaternion.slerp(q, 10 * delta);
            }
        }
    }

    // --- ENTITIES ---

    class EnemyTank {
        constructor() {
            this.mesh = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0044, wireframe: true });
            
            const shape = new THREE.Shape();
            shape.moveTo(-2,-2); shape.lineTo(-2,2); shape.lineTo(-1,2); shape.lineTo(-1,0);
            shape.lineTo(1,0); shape.lineTo(1,2); shape.lineTo(2,2); shape.lineTo(2,-2); shape.lineTo(-2,-2);
            const extrude = new THREE.ExtrudeGeometry(shape, { depth: 1, bevelEnabled: false });
            const body = new THREE.Mesh(extrude, bodyMat);
            body.rotation.x = -Math.PI/2;
            body.position.y = 0.5;
            this.mesh.add(body);

            const turret = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), bodyMat);
            turret.position.y = 2;
            this.mesh.add(turret);

            this.mesh.position.set((Math.random()-0.5)*100, 0, (Math.random()-0.5)*100);
            this.speed = 12;
            this.fireTimer = 0;
            this.state = 'CHASE'; 
        }

        update(delta, playerPos, playerVel) {
            const dist = this.mesh.position.distanceTo(playerPos);
            
            // AI Logic
            let target = playerPos.clone();
            
            if (dist < 15) {
                this.state = 'FLANK'; 
            } else if (dist > 30) {
                this.state = 'CHASE';
            }

            // Predictive Targeting
            const prediction = playerPos.clone().add(playerVel.clone().multiplyScalar(dist / 20)); 

            if (this.state === 'CHASE') {
                this.mesh.lookAt(prediction);
                this.mesh.translateZ(this.speed * delta);
            } else if (this.state === 'FLANK') {
                this.mesh.lookAt(playerPos);
                this.mesh.translateX(this.speed * delta * 0.8); // Strafe
                this.mesh.translateZ(this.speed * delta * 0.2); // Slowly close in
            }

            // Fire Logic
            this.fireTimer -= delta;
            if (this.fireTimer <= 0 && dist < 40) {
                this.fire(prediction);
                this.fireTimer = 2.0;
            }
        }

        fire(target) {
            // Visual Laser Beam
            const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const pts = [new THREE.Vector3(0, 2, 0), new THREE.Vector3(0, 2, 40)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const laser = new THREE.Line(geo, laserMat);
            laser.position.copy(this.mesh.position);
            laser.lookAt(target);
            scene.add(laser);
            setTimeout(() => scene.remove(laser), 100);
            audioSystem.playTone(100, 'sawtooth', 0.1, 0.2); // Zap sound
        }
    }

    class LightCycle {
        constructor(colorHex, type) {
            this.mesh = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.2, metalness: 0.8 });
            const glowMat = new THREE.MeshBasicMaterial({ color: colorHex });
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5, metalness: 0.5 });
            const canopyMat = new THREE.MeshPhysicalMaterial({ color: 0x222222, transmission: 0.5, roughness: 0, thickness: 1.0 });

            const chassisGeo = new THREE.BoxGeometry(1.5, 1.0, 3.5);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat);
            chassis.position.y = 0.8;
            this.mesh.add(chassis);

            const canopyGeo = new THREE.BoxGeometry(1.2, 0.6, 2.0);
            const canopy = new THREE.Mesh(canopyGeo, canopyMat);
            canopy.position.set(0, 1.5, -0.2);
            this.mesh.add(canopy);

            const wheelGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 32);
            wheelGeo.rotateZ(Math.PI / 2);
            const rearWheel = new THREE.Mesh(wheelGeo, wheelMat); rearWheel.position.set(0, 1.2, 1.8); this.mesh.add(rearWheel);
            const frontWheel = new THREE.Mesh(wheelGeo, wheelMat); frontWheel.position.set(0, 1.2, -1.8); this.mesh.add(frontWheel);

            const rimGeo = new THREE.TorusGeometry(1.2, 0.05, 8, 32); rimGeo.rotateY(Math.PI / 2);
            const rRim = new THREE.Mesh(rimGeo, glowMat); rRim.position.set(0, 1.2, 1.8); this.mesh.add(rRim);
            const fRim = new THREE.Mesh(rimGeo, glowMat); fRim.position.set(0, 1.2, -1.8); this.mesh.add(fRim);

            const trail = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 2), new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
            trail.rotation.x = Math.PI/2; trail.position.set(0, 1, 4); trail.scale.y = 15; this.mesh.add(trail);

            this.speed = 45; this.direction = Math.random() > 0.5 ? 1 : -1; this.axis = type;
            const offset = (Math.random() - 0.5) * 150;
            if(this.axis === 'x') { this.mesh.position.set(offset, 0, (Math.random() > 0.5 ? 80 : -80)); this.mesh.rotation.y = this.direction === 1 ? Math.PI/2 : -Math.PI/2; }
            else { this.mesh.position.set((Math.random() > 0.5 ? 80 : -80), 0, offset); this.mesh.rotation.y = this.direction === 1 ? 0 : Math.PI; }
        }
        update(delta) {
            const move = this.speed * delta * this.direction;
            if (this.axis === 'x') { this.mesh.position.x += move; if(Math.abs(this.mesh.position.x) > 150) this.direction *= -1; }
            else { this.mesh.position.z += move; if(Math.abs(this.mesh.position.z) > 150) this.direction *= -1; }
            this.mesh.rotation.y = this.axis === 'x' ? (this.direction === 1 ? Math.PI/2 : -Math.PI/2) : (this.direction === 1 ? 0 : Math.PI);
        }
    }

    function createLightCycles() {
        const colors = [0xffea00, 0x00aaff, 0xff00aa]; 
        for(let i=0; i<6; i++) {
            const cycle = new LightCycle(colors[i % 3], i%2===0?'x':'z');
            lightCycles.push(cycle);
            scene.add(cycle.mesh);
        }
    }

    function createTanks() {
        for(let i=0; i<4; i++) {
            const tank = new EnemyTank();
            tanks.push(tank);
            scene.add(tank.mesh);
        }
    }

    // --- REVERTED: Simple Vector Cursors (Octahedrons) ---
    function createCursors() {
        const geo = new THREE.OctahedronGeometry(1.5); 
        const matYes = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const matNo = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        
        for(let i=0; i<20; i++) {
            const isYes = Math.random() > 0.4;
            const cursor = new THREE.Mesh(geo, isYes ? matYes.clone() : matNo.clone());
            cursor.userData = { type: isYes ? 'YES' : 'NO' };
            cursor.position.set((Math.random()-0.5)*120, 3, (Math.random()-0.5)*120);
            cursors.push(cursor);
            scene.add(cursor);
        }
    }

    function createVectorEnvironment() {
        const grid = new THREE.GridHelper(300, 60, 0x0044aa, 0x001122); scene.add(grid);
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(600, 600), new THREE.MeshBasicMaterial({ color: 0x020205 }));
        floor.rotation.x = -Math.PI / 2; floor.position.y = -0.1; scene.add(floor);
    }

    // --- CONTROLS ---
    function setupJoystick() {
        const zone = document.getElementById('joystick-zone');
        const knob = document.getElementById('joystick-knob');
        let rect;

        zone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            rect = zone.getBoundingClientRect();
            updateStick(e.touches[0]);
            knob.style.background = 'rgba(0, 255, 255, 0.5)';
            knob.style.borderColor = 'rgba(0, 255, 255, 1)';
        });

        zone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            updateStick(e.touches[0]);
        });

        zone.addEventListener('touchend', (e) => {
            e.preventDefault();
            knob.style.transform = `translate(-50%, -50%)`;
            knob.style.background = 'rgba(0, 255, 255, 0.3)';
            knob.style.borderColor = 'rgba(0, 255, 255, 0.8)';
            input.x = 0;
            input.y = 0;
        });

        function updateStick(touch) {
            const maxDist = 70; // Increased for larger joystick
            let dx = touch.clientX - (rect.left + rect.width/2);
            let dy = touch.clientY - (rect.top + rect.height/2);
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
            const angle = Math.atan2(dy, dx);
            knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
            input.x = (Math.cos(angle)*dist)/maxDist;
            input.y = (Math.sin(angle)*dist)/maxDist;
        }
    }

    function setupMobileZoom() {
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');

        if (zoomInBtn && zoomOutBtn) {
            zoomInBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                targetCameraZoom = Math.max(10, targetCameraZoom - 5);
                audioSystem.playTone(800, 'sine', 0.05, 0.1);
            });

            zoomOutBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                targetCameraZoom = Math.min(120, targetCameraZoom + 5);
                audioSystem.playTone(600, 'sine', 0.05, 0.1);
            });

            // Also support click for desktop testing
            zoomInBtn.addEventListener('click', (e) => {
                e.preventDefault();
                targetCameraZoom = Math.max(10, targetCameraZoom - 5);
            });

            zoomOutBtn.addEventListener('click', (e) => {
                e.preventDefault();
                targetCameraZoom = Math.min(120, targetCameraZoom + 5);
            });
        }
    }

    function onMouseDown(e) { 
        isDragging = true; 
        previousMouseX = e.clientX; 
        previousMouseY = e.clientY;
    }
    function onMouseUp(e) { isDragging = false; }
    
    function onMouseMove(e) { 
        if(isDragging) {
            const deltaX = e.clientX - previousMouseX;
            const deltaY = e.clientY - previousMouseY;
            
            cameraAngle -= deltaX * 0.005; 
            cameraHeightFactor += deltaY * 0.005; 
            cameraHeightFactor = Math.max(0.3, Math.min(cameraHeightFactor, 2.5)); 
            
            previousMouseX = e.clientX;
            previousMouseY = e.clientY;
        }
    }
    
    let prevTouchX = 0;
    let prevTouchY = 0;
    let prevPinchDist = 0;
    let isPinching = false;

    function onTouchStart(e) {
        if (e.target.id === 'joystick-zone' || e.target.classList.contains('zoom-btn')) return;

        if (e.touches.length === 2) {
            // Two fingers - start pinch zoom
            isPinching = true;
            isDragging = false;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            prevPinchDist = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
        } else if (e.touches.length === 1) {
            // One finger - camera rotation
            isDragging = true;
            isPinching = false;
            prevTouchX = e.touches[0].clientX;
            prevTouchY = e.touches[0].clientY;
        }
    }

    function onTouchMove(e) {
        if (e.target.id === 'joystick-zone' || e.target.classList.contains('zoom-btn')) return;

        if (e.touches.length === 2 && isPinching) {
            // Pinch zoom with two fingers
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentPinchDist = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );

            const pinchDelta = prevPinchDist - currentPinchDist;
            targetCameraZoom += pinchDelta * 0.15;
            targetCameraZoom = Math.max(10, Math.min(targetCameraZoom, 120));

            prevPinchDist = currentPinchDist;
        } else if (e.touches.length === 1 && isDragging && !isPinching) {
            // Camera rotation with one finger
            const deltaX = e.touches[0].clientX - prevTouchX;
            const deltaY = e.touches[0].clientY - prevTouchY;

            cameraAngle -= deltaX * 0.008;
            cameraHeightFactor += deltaY * 0.008;
            cameraHeightFactor = Math.max(0.3, Math.min(cameraHeightFactor, 2.5));

            prevTouchX = e.touches[0].clientX;
            prevTouchY = e.touches[0].clientY;
        }
    }

    function onTouchEnd(e) {
        if (e.touches.length < 2) {
            isPinching = false;
        }
        if (e.touches.length === 0) {
            isDragging = false;
        }
    }

    function onMouseWheel(event) {
        event.preventDefault();
        targetCameraZoom += event.deltaY * 0.05; 
        targetCameraZoom = Math.max(10, Math.min(targetCameraZoom, 120));
    }

    function onKeyDown(e) { 
        switch(e.key.toLowerCase()) { 
            case 'w': input.y = -1; break; case 's': input.y = 1; break; case 'a': input.x = -1; break; case 'd': input.x = 1; break; 
            case 'c': switchCharacter(); break;
        } 
    }
    function onKeyUp(e) { switch(e.key.toLowerCase()) { case 'w': case 's': input.y = 0; break; case 'a': case 'd': input.x = 0; break; } }
    function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }

    function switchCharacter() {
        if(!playerRobot) return;
        const types = [
            'INVADER', 'GHOST', 'SHIP', 'TANK', 'GLIDER', 
            'PLUMBER', 'FACE', 'SWORD', 'BLOCK', 'PONG',
            'DISK', 'BUG', 'HEART', 'KEY', 'EYE',
            'MECH', 'ALIEN', 'SAMURAI', 'CYBORG', 'DRAGON'
        ];
        const currentIdx = types.indexOf(playerRobot.type);
        const nextIdx = (currentIdx + 1) % types.length;
        playerRobot.switchType(types[nextIdx]);
        audioSystem.playTone(600, 'square', 0.1, 0.2);
    }

    function resetPlayer() {
        if (!playerRobot) return;
        playerRobot.mesh.position.set(0, 2, 0);
        playerRobot.velocity.set(0, 0, 0);
        cameraAngle = 0;
        cameraHeightFactor = 1.0;
        audioSystem.playTone(300, 'sawtooth', 0.5, 0.5);
        
        const board = document.getElementById('score-val');
        board.innerText = "RESET";
        board.style.color = "#00ffff";
        setTimeout(() => { 
            board.innerText = score; 
            board.style.color = "#fff"; 
        }, 1000);
    }

    function updateScore(val) {
        score += val;
        const board = document.getElementById('score-val');
        board.innerText = score;
        board.style.color = val > 0 ? '#00ff00' : '#ff0000';
        setTimeout(() => board.style.color = '#fff', 300);
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        
        cameraZoom += (targetCameraZoom - cameraZoom) * 0.08;

        if (playerRobot) {
            playerRobot.update(delta, input, cameraAngle);
            
            if (playerRobot.mesh.position.y < -30) {
                resetPlayer();
            }

            const stableTarget = new THREE.Vector3(
                playerRobot.mesh.position.x, 
                2.0, 
                playerRobot.mesh.position.z
            );

            const orbitRadius = cameraZoom;
            const camX = stableTarget.x + orbitRadius * Math.sin(cameraAngle);
            const camZ = stableTarget.z + orbitRadius * Math.cos(cameraAngle);
            const camY = stableTarget.y + orbitRadius * cameraHeightFactor; 
            
            camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.08); 
            camera.lookAt(stableTarget);
            
            cursors.forEach(c => {
                c.rotation.y += delta; 
                if(c.position.distanceTo(playerRobot.mesh.position) < 3.0) {
                    c.position.set((Math.random()-0.5)*120, 3, (Math.random()-0.5)*120);
                    const isYes = c.userData.type === 'YES';
                    if (isYes) {
                        updateScore(100);
                        audioSystem.speak("Yes", 1.2);
                        audioSystem.playTone(880, 'sine', 0.1, 0.1, 2000, true);
                    } else {
                        updateScore(-50);
                        audioSystem.speak("No", 0.8);
                        audioSystem.playTone(150, 'sawtooth', 0.2, 0.1);
                    }
                }
            });

            [...tanks, ...lightCycles].forEach(e => {
                const enemyMesh = e.mesh ? e.mesh : e;
                if(e.update && e instanceof EnemyTank) e.update(delta, playerRobot.mesh.position, playerRobot.velocity);
                
                if(enemyMesh && enemyMesh.position && enemyMesh.position.distanceTo(playerRobot.mesh.position) < 4.0) {
                    updateScore(-50);
                    playerRobot.velocity.negate().multiplyScalar(1.5);
                    playerRobot.setExpression('HURT');
                    audioSystem.speak("Collision", 1.5);
                }
            });
        }

        updateMCP(delta);
        lightCycles.forEach(c => c.update(delta));
        composer.render();
    }

    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('overlay').style.opacity = 0;
        setTimeout(() => document.getElementById('overlay').style.display = 'none', 800);

        // Warm up speech synthesis for mobile (requires user interaction)
        if (window.speechSynthesis) {
            // Create a silent utterance to initialize speech on mobile
            const warmup = new SpeechSynthesisUtterance('');
            warmup.volume = 0;
            window.speechSynthesis.speak(warmup);

            // Load voices again to ensure they're available
            const voices = window.speechSynthesis.getVoices();
            if (voices.length === 0) {
                // Force voice loading on mobile
                window.speechSynthesis.getVoices();
            }
        }

        init();
        isPlaying = true;
        audioSystem.init();
    });
    
    document.getElementById('switch-char-btn').addEventListener('click', switchCharacter);
    document.getElementById('reset-pos-btn').addEventListener('click', resetPlayer);

</script>
</body>
</html>